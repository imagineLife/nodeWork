## Practice
1 - Create an eventEmitter object
  - include 2 parts, a constructor and a destroy method
    - set destroy to...
      - be a fn that takes a `err` arg
      - if err, emit an error event, passing the err as the data
      - emit a close event
- 2
  - Create an EventEmitter var, built from a new EventEmitter constructor
  - listen for a 'close' event, where logs `close event fired!`
  - emit close event
- 3
  - create an eventEmitter var from EventEmitter constructor
  - on event-a, log `1st string`
  - on event-a, again, log `2st string`
  - emit 'my-event'
- 4
  - create an eventEmitter var from EventEmitter constructor
  - on event-a, only the first time it is fired, log `event fired`
  - emit `event-a` 3x, and the `event fired` string should only log 1x
- 5
  - create an eventEmitter from an EE constructor
  - register a close listener
    - logging `close event`
  - emit a close event
- 6
  - create an eventEmitter from an EE constructor
  - register an event listener for a `new-event` event
    - set a console.log('new-event fired') as the response of the `new-event` listener
  - inject a listener into the top position on the `new-event`, logging `injected here`
- 7
  - create an eventEmitter from an EE constructor
  - set a listener for an event `do-this`
    - set this listener to 'remove' itself after it has been called 1x
    - log 'this done' in the handler
    - emit `do-this` 3x, && the output should only happen 1x
- 8
  - create an eventEmitter from an EE constructor
  - keep the process alive (process.stdin.resume())
  - emit an error, returning an error object + string combo of 'uh-oh'
    - SHOULD show the error in the terminal
- 9
  - create an eventEmitter from an EE constructor
  - keep the process alive (process.stdin.resume())
  - register an error listener, logging a string with `got error: ${err.message}`
  - emit an error, returning an error object + string combo of 'uh-oh'
    - SHOULD show a string in the terminal
    - 